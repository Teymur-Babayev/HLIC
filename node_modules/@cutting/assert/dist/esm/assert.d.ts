declare enum FailureType {
    Condition = "Condition",
    NoValue = "NoValue"
}
type ErrorFormatter = (failureType: FailureType, message?: string, props?: object) => string;
type ErrorCreator = (failureType: FailureType, message?: string, props?: object) => Error;
type ErrorReporter = (failureType: FailureType, error: Error, message?: string, props?: object) => void;
type WarningReporter = (failureType: FailureType, message?: string, props?: object) => void;
export type AssertConfiguration = {
    formatter?: ErrorFormatter;
    errorCreator?: ErrorCreator;
    errorReporter?: ErrorReporter;
    warningReporter?: WarningReporter;
};
/**
 * Customize formatting of assertion failure messages, creation of failure Errors and reporting of failures
 * @param custom
 */
export declare function configureAssert(custom: AssertConfiguration): void;
/**
 * For test purpose
 */
export declare function testResetConfiguration(): void;
interface Assert {
    /**
     * Verify that a condition is satisfied.
     * @param condition Condition to be true
     * @param message Error message
     * @param props Any props relevant.
     * @throws Throws exception if condition is false.
     */
    (condition: boolean, message?: string, props?: object | (() => object)): asserts condition;
    /**
     * Verify that an optional value actually has a proper value in this context, i.e. not null or undefined.
     * @param value Value to be verified
     * @param message Error message
     * @param props If message is a string id, format any matching key values into message. Props are also reported to dev team.
     * @throws Throws exception if value is null or undefined
     */
    <T>(value: T | undefined | null, message?: string, props?: object | (() => object)): T;
}
export declare const assert: Assert;
export {};
//# sourceMappingURL=assert.d.ts.map