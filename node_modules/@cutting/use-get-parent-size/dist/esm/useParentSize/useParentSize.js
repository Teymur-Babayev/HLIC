import { useCallback, useMemo, useRef, useState } from 'react';
import ResizeObserver from 'resize-observer-polyfill';
import { useDebouncedCallback } from 'use-debounce';
import { identity, isNil } from './util';
import { assert } from '@cutting/assert';
import { useIsomorphicLayoutEffect } from './useIsomorphicLayoutEffect';
const initialContentRect = {
    bottom: undefined,
    height: undefined,
    left: undefined,
    width: undefined,
    right: undefined,
    top: undefined,
    x: undefined,
    y: undefined,
};
export const useParentSize = (ref, { debounceDelay = 500, initialValues = initialContentRect, transformFunc = (o) => o, maxDifference = 10, callback = identity, } = {}) => {
    const [contentRect, setContentRect] = useState({
        ...initialContentRect,
        ...initialValues,
    });
    const rerenderCount = useRef(0);
    const previousContentRect = useRef(initialValues);
    const transformer = useCallback(transformFunc, [transformFunc]);
    assert(!!ref, 'You must pass a valid ref to useParentSize');
    const debouncedCallback = useDebouncedCallback((value) => {
        setContentRect(value);
        callback(value);
    }, debounceDelay, {
        leading: true,
    });
    const refElement = ref.current;
    useIsomorphicLayoutEffect(() => {
        if (isNil(refElement)) {
            if (rerenderCount.current > 10) {
                throw new Error('Maximum rerender count and no refElement Found');
            }
            setContentRect({ ...contentRect });
            rerenderCount.current++;
            return;
        }
        const resizeObserver = new ResizeObserver((entries) => {
            if (!Array.isArray(entries) || entries.length !== 1) {
                return;
            }
            const entry = entries[0];
            const newWidth = Math.round(entry.contentRect.width);
            const newHeight = Math.round(entry.contentRect.height);
            const widthDiff = Math.abs(newWidth - (previousContentRect.current.width ?? 0));
            const heightDiff = Math.abs(newHeight - (previousContentRect.current.height ?? 0));
            if (widthDiff > maxDifference || heightDiff > maxDifference) {
                previousContentRect.current.height = newHeight;
                previousContentRect.current.width = newWidth;
                debouncedCallback(entry.contentRect);
            }
        });
        requestAnimationFrame(() => resizeObserver?.observe(refElement));
        return () => {
            if (!!refElement) {
                resizeObserver?.unobserve(refElement);
            }
        };
    }, [maxDifference, debouncedCallback, refElement, initialValues, contentRect]);
    return useMemo(() => transformer(contentRect), [contentRect, transformer]);
};
//# sourceMappingURL=useParentSize.js.map