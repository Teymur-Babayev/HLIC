import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import TorusEmbed from '@toruslabs/torus-embed';
import { Web3AuthError, WALLET_ADAPTERS, ADAPTER_STATUS, ADAPTER_EVENTS } from '@web3auth/base';
import { PLUGIN_NAMESPACES } from '@web3auth/base-plugin';
import log from 'loglevel';

class TorusWalletPluginError extends Web3AuthError {
  constructor(code, message) {
    // takes care of stack and proto
    super(code, message);

    // Set name explicitly as minification can mangle class names
    Object.defineProperty(this, "name", {
      value: "TorusWalletPluginError"
    });
  }
  static fromCode(code) {
    let extraMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
    return new TorusWalletPluginError(code, `${TorusWalletPluginError.messages[code]}${extraMessage}`);
  }
  static notInitialized() {
    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    return TorusWalletPluginError.fromCode(5210, extraMessage);
  }
  static unsupportedAdapter() {
    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    return TorusWalletPluginError.fromCode(5211, extraMessage);
  }
  static providerRequired() {
    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    return TorusWalletPluginError.fromCode(5212, extraMessage);
  }
  static web3authRequired() {
    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    return TorusWalletPluginError.fromCode(5213, extraMessage);
  }
  static web3AuthNotConnected() {
    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    return TorusWalletPluginError.fromCode(5214, extraMessage);
  }
  static userInfoRequired() {
    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    return TorusWalletPluginError.fromCode(5215, extraMessage);
  }
  static alreadyInitialized() {
    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    return TorusWalletPluginError.fromCode(5216, extraMessage);
  }
  static torusWalletNotSet() {
    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    return TorusWalletPluginError.fromCode(5217, extraMessage);
  }
  static unsupportedChainNamespace() {
    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    return TorusWalletPluginError.fromCode(5218, extraMessage);
  }
}
_defineProperty(TorusWalletPluginError, "messages", {
  5210: "Torus Wallet Plugin is not initialized",
  5211: "Web3Auth is connected to unsupported adapter. Torus wallet connector plugin requires web3auth connected to openlogin adapter.",
  5212: "Provider is required..",
  5213: "Web3Auth instance is required while initialization.",
  5214: "Web3Auth is not connected.",
  5215: "UserInfo is required.",
  5216: "Plugin is already initialized",
  5217: "Torus wallet instance is not set."
});

class TorusWalletConnectorPlugin {
  constructor(options) {
    _defineProperty(this, "name", "TORUS_WALLET_CONNECTOR_PLUGIN");
    _defineProperty(this, "SUPPORTED_ADAPTERS", [WALLET_ADAPTERS.OPENLOGIN]);
    _defineProperty(this, "pluginNamespace", PLUGIN_NAMESPACES.EIP155);
    _defineProperty(this, "torusWalletInstance", void 0);
    _defineProperty(this, "provider", null);
    _defineProperty(this, "web3auth", null);
    _defineProperty(this, "userInfo", null);
    _defineProperty(this, "isInitialized", false);
    _defineProperty(this, "walletInitOptions", null);
    const {
      torusWalletOpts = {},
      walletInitOptions
    } = options;
    const whiteLabel = walletInitOptions === null || walletInitOptions === void 0 ? void 0 : walletInitOptions.whiteLabel;
    if (!whiteLabel) throw new Error("whiteLabel is required");
    const {
      logoDark,
      logoLight
    } = whiteLabel;
    if (!logoDark || !logoLight) throw new Error("logoDark and logoLight are required in whiteLabel config");
    this.torusWalletInstance = new TorusEmbed(torusWalletOpts);
    if (typeof walletInitOptions.showTorusButton === "undefined") walletInitOptions.showTorusButton = true;
    this.walletInitOptions = walletInitOptions;
  }
  get proxyProvider() {
    return this.torusWalletInstance.isLoggedIn ? this.torusWalletInstance.provider : null;
  }
  async initWithWeb3Auth(web3auth) {
    if (this.isInitialized) return;
    if (!web3auth) throw TorusWalletPluginError.web3authRequired();
    if (web3auth.provider && web3auth.connectedAdapterName !== WALLET_ADAPTERS.OPENLOGIN) throw TorusWalletPluginError.unsupportedAdapter();
    if (web3auth.coreOptions.chainConfig.chainNamespace !== this.pluginNamespace) throw TorusWalletPluginError.unsupportedChainNamespace();
    // Not connected yet to openlogin
    if (web3auth.provider) {
      this.provider = web3auth.provider;
      this.userInfo = await web3auth.getUserInfo();
    }
    this.web3auth = web3auth;
    this.subscribeToWeb3AuthNoModalEvents(web3auth);
    const connectedChainConfig = web3auth.coreOptions.chainConfig;
    const network = _objectSpread(_objectSpread({}, web3auth.coreOptions.chainConfig), {}, {
      networkName: connectedChainConfig.displayName,
      host: connectedChainConfig.rpcTarget,
      chainId: parseInt(connectedChainConfig.chainId, 16)
    });
    await this.torusWalletInstance.init(_objectSpread(_objectSpread({}, this.walletInitOptions || {}), {}, {
      network,
      showTorusButton: false
    }));
    this.isInitialized = true;
  }
  async initWithProvider(provider, userInfo) {
    if (this.isInitialized) return;
    if (!userInfo) throw TorusWalletPluginError.userInfoRequired();
    if (!provider) throw TorusWalletPluginError.providerRequired();
    this.provider = provider;
    this.userInfo = userInfo;
    await this.torusWalletInstance.init(this.walletInitOptions || {});
    this.isInitialized = true;
  }
  async connect() {
    // if web3auth is being used and connected to unsupported adapter throw error
    if (this.web3auth && this.web3auth.connectedAdapterName !== WALLET_ADAPTERS.OPENLOGIN) throw TorusWalletPluginError.unsupportedAdapter();
    if (!this.isInitialized) throw TorusWalletPluginError.notInitialized();
    // Not connected yet to openlogin
    if (!this.provider) {
      var _this$web3auth;
      if ((_this$web3auth = this.web3auth) !== null && _this$web3auth !== void 0 && _this$web3auth.provider) {
        this.provider = this.web3auth.provider;
        this.userInfo = await this.web3auth.getUserInfo();
      } else if (this.web3auth) {
        throw TorusWalletPluginError.web3AuthNotConnected();
      } else {
        throw TorusWalletPluginError.providerRequired();
      }
    }
    let privateKey;
    try {
      // it should throw if provider doesn't support `eth_private_key` function
      privateKey = await this.provider.request({
        method: "eth_private_key"
      });
    } catch (error) {
      log.warn("unsupported method", error, TorusWalletPluginError.unsupportedAdapter());
      if ((error === null || error === void 0 ? void 0 : error.code) === -32004) throw TorusWalletPluginError.unsupportedAdapter();
      throw error;
    }
    if (!privateKey) throw TorusWalletPluginError.web3AuthNotConnected();
    try {
      var _this$userInfo, _this$userInfo2, _this$userInfo3, _this$userInfo4, _this$walletInitOptio;
      await this.torusWalletInstance.loginWithPrivateKey({
        privateKey,
        userInfo: _objectSpread(_objectSpread({}, this.userInfo), {}, {
          email: (_this$userInfo = this.userInfo) === null || _this$userInfo === void 0 ? void 0 : _this$userInfo.email,
          name: (_this$userInfo2 = this.userInfo) === null || _this$userInfo2 === void 0 ? void 0 : _this$userInfo2.name,
          profileImage: (_this$userInfo3 = this.userInfo) === null || _this$userInfo3 === void 0 ? void 0 : _this$userInfo3.profileImage,
          typeOfLogin: (_this$userInfo4 = this.userInfo) === null || _this$userInfo4 === void 0 ? void 0 : _this$userInfo4.typeOfLogin // openlogin's login type is subset of torus embed, so it is safe to cast.
        })
      });
      if ((_this$walletInitOptio = this.walletInitOptions) !== null && _this$walletInitOptio !== void 0 && _this$walletInitOptio.showTorusButton) this.torusWalletInstance.showTorusButton();
      this.subscribeToProviderEvents(this.provider);
      this.subscribeToWalletEvents();
    } catch (error) {
      log.error(error);
    }
  }
  async showWalletConnectScanner() {
    if (!this.torusWalletInstance.isLoggedIn) throw TorusWalletPluginError.web3AuthNotConnected();
    await this.torusWalletInstance.showWalletConnectScanner();
  }
  async initiateTopup(provider, params) {
    if (!this.torusWalletInstance.isLoggedIn) throw TorusWalletPluginError.web3AuthNotConnected();
    await this.torusWalletInstance.initiateTopup(provider, params);
  }
  async disconnect() {
    var _this$web3auth2;
    // if web3auth is being used and connected to unsupported adapter throw error
    if (((_this$web3auth2 = this.web3auth) === null || _this$web3auth2 === void 0 ? void 0 : _this$web3auth2.connectedAdapterName) !== WALLET_ADAPTERS.OPENLOGIN) throw TorusWalletPluginError.unsupportedAdapter();
    if (this.torusWalletInstance.isLoggedIn) {
      await this.torusWalletInstance.logout();
    } else {
      throw new Error("Torus Wallet plugin is not connected");
    }
  }
  subscribeToWalletEvents() {
    var _this$torusWalletInst,
      _this = this;
    (_this$torusWalletInst = this.torusWalletInstance) === null || _this$torusWalletInst === void 0 || _this$torusWalletInst.provider.on("accountsChanged", function () {
      let accounts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      if (accounts.length === 0) {
        var _this$web3auth3, _this$web3auth4;
        _this.torusWalletInstance.hideTorusButton();
        if (((_this$web3auth3 = _this.web3auth) === null || _this$web3auth3 === void 0 ? void 0 : _this$web3auth3.status) === ADAPTER_STATUS.CONNECTED) (_this$web3auth4 = _this.web3auth) === null || _this$web3auth4 === void 0 || _this$web3auth4.logout();
      }
    });
  }
  subscribeToProviderEvents(provider) {
    var _this2 = this;
    provider.on("accountsChanged", function () {
      let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        accounts: []
      };
      _this2.setSelectedAddress(data.accounts[0]);
    });
    provider.on("chainChanged", chainId => {
      this.setChainID(parseInt(chainId, 16));
    });
    provider.on("disconnect", () => {
      this.torusWalletInstance.hideTorusButton();
    });
    provider.on("connect", () => {
      var _this$walletInitOptio2;
      if ((_this$walletInitOptio2 = this.walletInitOptions) !== null && _this$walletInitOptio2 !== void 0 && _this$walletInitOptio2.showTorusButton) this.torusWalletInstance.showTorusButton();
    });
  }
  subscribeToWeb3AuthNoModalEvents(web3Auth) {
    web3Auth.on(ADAPTER_EVENTS.CONNECTED, async () => {
      if (web3Auth.connectedAdapterName !== WALLET_ADAPTERS.OPENLOGIN) {
        log.warn(`${web3Auth.connectedAdapterName} is not compatible with torus wallet connector plugin`);
        return;
      }
      this.provider = web3Auth.provider;
      this.userInfo = await web3Auth.getUserInfo();
      if (!this.provider) throw TorusWalletPluginError.web3AuthNotConnected();
      this.subscribeToProviderEvents(this.provider);
    });
    web3Auth.on(ADAPTER_EVENTS.DISCONNECTED, async () => {
      this.provider = null;
      this.userInfo = null;
      if (this.torusWalletInstance.isLoggedIn) {
        await this.torusWalletInstance.logout();
      }
      this.torusWalletInstance.hideTorusButton();
    });
  }
  async sessionConfig() {
    if (!this.provider) throw TorusWalletPluginError.web3AuthNotConnected();
    const [accounts, chainId, privateKey, chainConfig] = await Promise.all([this.provider.request({
      method: "eth_accounts"
    }), this.provider.request({
      method: "eth_chainId"
    }), this.provider.request({
      method: "eth_private_key"
    }), this.provider.request({
      method: "eth_provider_config"
    })]);
    return {
      chainId: parseInt(chainId, 16),
      accounts: accounts,
      privateKey: privateKey,
      chainConfig: chainConfig
    };
  }
  async torusWalletSessionConfig() {
    if (!this.torusWalletInstance.provider) throw TorusWalletPluginError.web3AuthNotConnected();
    const [accounts, chainId] = await Promise.all([this.torusWalletInstance.provider.request({
      method: "eth_accounts"
    }), this.torusWalletInstance.provider.request({
      method: "eth_chainId"
    })]);
    return {
      chainId: parseInt(chainId, 16),
      accounts: accounts
    };
  }
  async setSelectedAddress(address) {
    var _torusWalletSessionCo;
    if (!this.torusWalletInstance.isLoggedIn || !this.userInfo) throw TorusWalletPluginError.web3AuthNotConnected();
    const [sessionConfig, torusWalletSessionConfig] = await Promise.all([this.sessionConfig(), this.torusWalletSessionConfig()]);
    if (address !== ((_torusWalletSessionCo = torusWalletSessionConfig.accounts) === null || _torusWalletSessionCo === void 0 ? void 0 : _torusWalletSessionCo[0])) {
      var _this$userInfo5, _this$userInfo6, _this$userInfo7, _this$userInfo8;
      await this.torusWalletInstance.loginWithPrivateKey({
        privateKey: sessionConfig.privateKey,
        userInfo: _objectSpread(_objectSpread({}, this.userInfo), {}, {
          email: (_this$userInfo5 = this.userInfo) === null || _this$userInfo5 === void 0 ? void 0 : _this$userInfo5.email,
          name: (_this$userInfo6 = this.userInfo) === null || _this$userInfo6 === void 0 ? void 0 : _this$userInfo6.name,
          profileImage: (_this$userInfo7 = this.userInfo) === null || _this$userInfo7 === void 0 ? void 0 : _this$userInfo7.profileImage,
          typeOfLogin: (_this$userInfo8 = this.userInfo) === null || _this$userInfo8 === void 0 ? void 0 : _this$userInfo8.typeOfLogin // openlogin's login type is subset of torus embed, so it is safe to cast.
        })
      });
    }
  }
  async setChainID(chainId) {
    const [sessionConfig, torusWalletSessionConfig] = await Promise.all([this.sessionConfig(), this.torusWalletSessionConfig()]);
    const {
      chainConfig
    } = sessionConfig || {};
    if (chainId !== torusWalletSessionConfig.chainId && chainConfig) {
      await this.torusWalletInstance.setProvider(_objectSpread(_objectSpread({}, chainConfig), {}, {
        chainId,
        host: chainConfig.rpcTarget,
        networkName: chainConfig.displayName
      }));
    }
  }
}

export { TorusWalletConnectorPlugin };
//# sourceMappingURL=torusWalletConnectorPlugin.esm.js.map
